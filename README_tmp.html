<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E5%9F%BA%E4%BA%8E-python-%E7%9A%84%E8%AF%8D%E8%BE%BE%E4%BA%BA%E7%AD%94%E9%A2%98%E8%84%9A%E6%9C%AC">基于 python 的词达人答题脚本</h1>
<p>openCV 图像+pytesseract 文本识别+pyautogui 实现自动操作+numpy 数值计算</p>
<h2 id="%E5%89%8D%E8%A8%80">前言</h2>
<p>我目前正在读大一,有一门课程的作业一直深深困扰着我,也就是词达人的作业.每次都有海量的单词的冗余的题目,不仅对于词汇的提高非常有限,反而增加了负担。而这样大量的重复工作正是每一个程序员所深恶痛绝的，因此在课程期间，我自学了
python 及其部分应用，在课余时间，我利用 python 编写了一个基于 openCV 图像+pytesseract 文本识别+pyautogui
实现自动操作+numpy 数值计算的词达人自动答题脚本。该脚本可以自动识别题目，自动选择答案，并自动提交答案，正确率可以稳定在
85%以上，大幅度实现了降本增效，这也正是编程的目的与乐趣所在。</p>
<h2 id="%E4%BB%A5%E4%B8%8B%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%A5%E5%91%8A%E5%86%85%E5%AE%B9">以下是程序设计报告内容</h2>
<p><strong>目录</strong></p>
<p>词达人答题脚本</p>
<p>第 一 章 绪论</p>
<p>1.1 开发环境</p>
<p>第二章 功能实现</p>
<p>2.1.1 答题模式</p>
<p>2.1.2 思路</p>
<p>第三章 详细设计</p>
<p>3.1 总体结构及功能模块划分</p>
<p>3.2 获取词典界面的单词和释义</p>
<p>3.3 获取题目和选项的文本内容</p>
<p>3.4 对比分析，获取最可能的选项列表</p>
<p>3.5 自动操作，流程处理</p>
<p>第四章 详细设计</p>
<p>第五章 主要功能模块代码</p>
<p>第六章 课程设计心得</p>
<h2 id="%E7%AC%AC-%E4%B8%80-%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><strong><em>第 一 章</em></strong> <strong><em>绪论</em></strong></h2>
<h3 id="11-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><strong>1.1</strong> <strong><em>开发环境</em></strong></h3>
<p><strong><em>开发工具</em></strong>: PyCharm2023。PyCharm 是由 JetBrains 公司开发的一款 Python 集成开发环境（IDE），被广泛认可为最优秀的 Python
开发工具之一。PyCharm 提供了丰富而强大的功能，包括智能代码提示、代码自动补全、代码重构、Python web 开发、版本控制工具集成（如
Git、SVN 等）、单元测试、代码分析以及创新的 GUI 设计支持等。本实验使用 Python3.8 开发 。</p>
<p><strong><em>开发语言</em></strong>: Python。Python 是一种高级面向对象的编程语言，它继承了多种语言的优点，并摒弃了其他语言中的复杂性，使得 Python
具有强大而简单易用的特点。Python 在设计之初就注重简洁、易读和可维护性，因此被称为一种“优雅的”编程语言。</p>
<p><strong><em>所用库</em></strong>:openCV, pytesseract, pyautogui,
numpy。OpenCV 主要用于对图片进行处理从而提高识别效率，使用 pytesseract 识别文本。pyautogui 可以通过 python
程序模拟人鼠标点击操作实现自动化，numpy 则用于数值高效计算，实现算法，提高自动化效率。</p>
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%88%86%E6%9E%90"><strong><em>第二章</em></strong> <strong>思路及分析</strong></h2>
<h4 id="211-%E7%AD%94%E9%A2%98%E6%A8%A1%E5%BC%8F">2.1.1 答题模式</h4>
<p>词达人的答题模式为：</p>
<p>（1）一次作业为一个小测试，一共有三十个词语，通过自由选择一定数量的词语进入练习。</p>
<p>（2）练习开头会用词典的形式展现单词的释义、词义。</p>
<p>（3）展示完所有选择的单词的词典界面之后，会给出与所选词数大致相等的练习题，形式为给出一段距离，其中关键词语用绿色标出，有四个选项对应该词语的释义，有两次机会做答，选择错误则进入下一题，答完题目即为完成。</p>
<p>（4）当所有词语都被选择完并作答后，该测试即为完成。</p>
<h4 id="212-%E6%80%9D%E8%B7%AF">2.1.2 思路</h4>
<p>（1） 识别文本，建立词典。由于答题界面的区域可通过 windows 的分屏功能和系统分辨率确定，固可以通过 openCV
识别功能记录单词和单词释义，创建一个临时词典。</p>
<p>（2） 提取题干，对比分析。通过 openCV 获取题干中的绿色单词和选项文本，通过对比分析和匹配算法，获取最可能的选项列表。</p>
<p>（3） 自动操作，流程处理。通过 pyautogui 实现自动操作，并按照一定的逻辑处理流程。</p>
<h2 id="%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><strong>第三章</strong> <strong>详细设计</strong></h2>
<h3 id="31-%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84%E5%8F%8A%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86"><strong>3.1</strong> <strong><em>总体结构及功能模块划分</em></strong></h3>
<p>运行时通过实例化 word 类，通过函数调用创建一个字典，并通过 answer 类中的逻辑处理执行答题。</p>
<p>可分为 Word 类，Answer 类，和 Const 类，Word 类用于识别文本创建词典，其中包含读取文本内容的静态函数</p>
<p>Word 类</p>
<p><img src="file:///g:/script/pic_used_in_word/word.png" alt="img"></p>
<p>Answer 类</p>
<p><img src="file:///g:/script/pic_used_in_word/answer.png" alt="img"></p>
<p>其中，const 类中存放的主要为一些常量和读取常量的函数，此处就不展示了。</p>
<p>下面进行详细流程设计和算法设计</p>
<h3 id="32-%E8%8E%B7%E5%8F%96%E8%AF%8D%E5%85%B8%E7%95%8C%E9%9D%A2%E7%9A%84%E5%8D%95%E8%AF%8D%E5%92%8C%E9%87%8A%E4%B9%89"><strong>3.2</strong> <strong><em>获取词典界面的单词和释义</em></strong></h3>
<p>通过记录数据，得到单词所在区域和释义所在区域，首先初始化一个 word 类，其含有一个空字典，用于生成词典。</p>
<p>对于获取英文单词，使用 openCV 进行预处理和使用特殊的 config 使得图像内容更加突出，提高准确率。函数如下</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_word_in_dic</span><span class="hljs-params">(word_image_path: str)</span> -&gt; str:</span>
    img = cv2.imread(word_image_path)
    gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="hljs-comment"># 将图像从彩色转换为灰度图像</span>
    word = pytesseract.image_to_string(gray_img, lang=<span class="hljs-string">"eng"</span>, config=ENGLISH_CONFIG)
    <span class="hljs-keyword">return</span> word.replace(<span class="hljs-string">"\n"</span>, <span class="hljs-string">""</span>)
</div></code></pre>
<p>其中</p>
<pre class="hljs"><code><div>ENGLISH_CONFIG =r'--oem 3 --psm 6 -c tessedit_char_whitelist=abcdefghijklmnopqrstuvwxyz.'# 配置大模型参数，并且设置识别白名单，用于提高英文识别准确率
</div></code></pre>
<p>&quot;--psm 6&quot;的意义是按行识别,
&quot;tessedit_char_whitelist&quot;的意义是设置识别白名单，只识别白名单中的字符，可以提高识别准确率,
&quot;--oem 3&quot;的意义是使用 Tesseract 的默认模型，可以提高识别准确率。
对于获取中文内容，同样使用预处理方式，使识别准确率提高</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_translation_in_dic</span><span class="hljs-params">(translation_image_path: str)</span> -&gt; list:</span>
    <span class="hljs-string">"""
    获取中文字段,同时可用于读取前30个词的翻译,和题干中的选项中文
    :param translation_image_path:
    :return:
    """</span>
    image = Image.open(translation_image_path)
    image = image.convert(<span class="hljs-string">'L'</span>)  <span class="hljs-comment"># 转换为灰度图</span>
    enhancer = ImageEnhance.Contrast(image)
    image = enhancer.enhance(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 提高对比度</span>
    image = image.filter(ImageFilter.MedianFilter())  <span class="hljs-comment"># 应用中值滤波去噪</span>
    image = image.point(<span class="hljs-keyword">lambda</span> x: <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">140</span> <span class="hljs-keyword">else</span> <span class="hljs-number">255</span>)
    result = pytesseract.image_to_string(
        image, lang=<span class="hljs-string">"chi_sim"</span>, config=<span class="hljs-string">r"--oem 3 --psm 6"</span>
    ).splitlines()
    <span class="hljs-comment"># 去除可能的空行,同时去除可能出现的多识别的非中文字符</span>
    result = [
        line.replace(<span class="hljs-string">" "</span>, <span class="hljs-string">""</span>)
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> result
        <span class="hljs-keyword">if</span> (line != <span class="hljs-string">""</span> <span class="hljs-keyword">and</span> (line.isalnum() == <span class="hljs-literal">False</span>))
    ]
    print(result)
    <span class="hljs-keyword">return</span> result
</div></code></pre>
<p>经过测试，识别中文比识别英文需要的预处理更加复杂，需要通过灰度图转换，对比度增强，中值滤波，二值化等操作，并且使用机器学习模型才能得到较好地识别效果。
通过以上两个函数，就可以通过对固定区域的截图，将图片路径作为参数传递，可以得到单词和对应中文释义，并点击继续按钮，从而创建词典。</p>
<h3 id="33-%E8%8E%B7%E5%8F%96%E9%A2%98%E7%9B%AE%E7%95%8C%E9%9D%A2%E7%9A%84%E5%8D%95%E8%AF%8D%E5%92%8C%E9%80%89%E9%A1%B9"><strong>3.3</strong> <strong><em>获取题目界面的单词和选项</em></strong></h3>
<p>由于题目界面与词典界面不同，题干中句子的关键词由绿色标记，其余的单词为黑色，所以为了识别出绿色的单词，需要对图片进行色彩转换，规定一个绿色的范围，后通过掩码标记，将不属于这个范围的像素点全部转化为白色，从而得到绿色单词。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_word_in_question</span><span class="hljs-params">(question_image_path: str)</span> -&gt; str:</span>
    <span class="hljs-string">"""
    获取题干中标记为绿色的单词,先使用掩码将非绿色部分标记为白色,之后读取转化后的图片获取单词
    :param question_image_path: 题干的图片路径
    :return:
    """</span>
    image = Image.open(question_image_path)
    image_cv = cv2.cvtColor(npy.array(image), cv2.COLOR_RGB2BGR)

    <span class="hljs-comment"># 定义绿色的 HSV 范围</span>
    lower_green = npy.array([<span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>])
    upper_green = npy.array([<span class="hljs-number">90</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>])

    <span class="hljs-comment"># 将图片转换为 HSV 格式，并根据绿色范围创建掩码,把绿色部分标记为黑色,其余部分为白色</span>
    hsv = cv2.cvtColor(image_cv, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, lower_green, upper_green)
    result = cv2.bitwise_and(image_cv, image_cv, mask=mask)
    result[mask == <span class="hljs-number">0</span>] = [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>]

    text = pytesseract.image_to_string(result, lang=<span class="hljs-string">"eng"</span>, config=ENGLISH_CONFIG)
    <span class="hljs-keyword">return</span> text.strip().lower().replace(<span class="hljs-string">" "</span>, <span class="hljs-string">""</span>)
</div></code></pre>
<p>效果如下：</p>
<p><img src="file:///g:/script/pic_used_in_word/green_word.png" alt="img"></p>
<p>便可以得到题干中的单词 arrogant</p>
<p>对于选项中的中文内容，这里有一个麻烦需要处理，由于不同的题干长度会导致题干占用的行数不同，从而使得选项所在区域是在变化的，解决办法就是先调用一个
getLine 函数，获取当前界面的总行数。由于选项的行数确定为 4 行，而且形状确定，所以可以由 getLines 返回的行数确定截取范围。这里使用的
python 的使用类名创建类的方法：</p>
<pre class="hljs"><code><div>line_name = eval(<span class="hljs-string">"Line"</span> + str(self.get_lines()))
line = line_name()
</div></code></pre>
<p>line_name()
定义在 const 文件中，每一个 line
对应的类中含有数据读取函数和对应的数据，记录了选项所在区域和鼠标点击的坐标数据。至此，准备工作已经基本完成，现在已经获取了所选词语的字典，并且能够准确识别题干的关键词和选项的内容，接下来就是答题的逻辑了。</p>
<h4 id="34-%E8%8E%B7%E5%8F%96%E6%9C%80%E4%BD%B3%E9%80%89%E9%A1%B9"><strong>3.4 获取最佳选项</strong></h4>
<p>对于获取最佳选项的函数：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_options</span><span class="hljs-params">(translations: list, options: list)</span> -&gt; list:</span>
    <span class="hljs-string">"""
    获取当前单词对应的可能选项
    :param translations:某一单词的字典翻译list
    :param options: 当前选项的list
    :return: 一个存有2个选项代号的list,记录了当前题目最可能的答案选项
    """</span>
</div></code></pre>
<p>我们希望返回一个列表，其中从索引 0 到 1 记录了最可能的两个选项（当然，这两个选项一定是不一样的），这里的“最可能”模仿的是人做题时的思考逻辑，即先思考关键词有哪些释义，然后观察选项思考最接近的意思。
这时，当单词仅仅有两个释义时，我们就可以直接返回这两个释义对应的最相似的选项；但是当单词有多个释义的时候，如果我们发现某一个释义在选项中找不到比较接近的（即释义和选项之间的最高匹配度较低），那就说明答案一定不会和这个释义对应。那么我们就可以依据释义与选项之间的最高匹配度进行排序，从而得到最可能在选项出现答案中的两个释义，并获取其对应的选项返回。
因此我们可以设计一个算法，通过多次排序和比较，返回一个 2 元列表，列表中记录了最可能的选项。</p>
<p>具体的算法设计如下：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_options</span><span class="hljs-params">(translations: list, options: list)</span> -&gt; list:</span>
    <span class="hljs-string">"""
    获取当前单词对应的可能选项
    :param translations:某一单词的字典翻译list
    :param options: 当前选项的list
    :return: 一个存有4个选项代号的list,记录了当前单词最可能的选项list
    """</span>
    print(<span class="hljs-string">"单词释义为"</span> + str(translations))
    options_dict = {}
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):
        <span class="hljs-comment"># 每个选项内容对应一个按钮编号1-4</span>
        options_dict[options[j]] = j
    options_result = []
    <span class="hljs-comment"># 只会有两次点击机会</span>
    max_sim_of_translation = {}
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(len(translations)):
        sim = {}
        <span class="hljs-keyword">for</span> option <span class="hljs-keyword">in</span> options:
            sim[option] = Answer.get_similarity(translations[t], option)  <span class="hljs-comment"># 对于每一个释义，获取每一个选项与其的相似度</span>
        sim = sorted(sim.items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 从高到低排序</span>
        max_sim_of_translation[translations[t]] = sim[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 记录当前释义的最大相似度 其值为一个元组（选项，相似度）</span>
    max_sim_of_translation = sorted(max_sim_of_translation.items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)
    options_result.append(options_dict[max_sim_of_translation[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]])
    options_result.append(options_dict[max_sim_of_translation[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]])
    print(options_result)
    <span class="hljs-keyword">return</span> options_result
</div></code></pre>
<p>因此，还需要设计一个返回字符串匹配度的函数，这里分为中文和英文判别。
对于中文判断，使用 jacquard 算法,用于获取正确选项：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_similarity</span><span class="hljs-params">(str1: str, str2: str)</span> -&gt; float:</span>
    <span class="hljs-string">"""
    获取两组字符的相似度,使用jacquard算法,用于获取正确选项
    :return: 相似值,∈[0,1],越高说明越相似
    """</span>
    set1 = set(str1)
    set2 = set(str2)
    intersection = len(set1.intersection(set2))
    union = len(set1.union(set2))
    <span class="hljs-keyword">return</span> intersection / union
</div></code></pre>
<p>对于英文单词则相对复杂，由于英文单词在词典中以原型储存，而在句子中会出现各种时态，因此需要先将句子中的单词与词典中的词一一匹配字符串，这里需要考虑到字符顺序，返回两组字符串按照同一顺序的最大相同字符占比。
算法设计如下：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_origin_word</span><span class="hljs-params">(word_get: str, word_dic: dict)</span> -&gt; str:</span>
    <span class="hljs-string">"""
    获取当前单词的词根
    :param word_dic: 词典
    :param word_get: 当前题中的单词
    :return: 当前单词的词根
    """</span>
    word_res = word_get
    word_len = len(word_get)
    max_similarity = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> word_dic.keys():
        max_len = max(len(word), word_len)
        min_len = min(len(word), word_len)
        same = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(min_len):
            <span class="hljs-keyword">if</span> word_get[i] == word[i]:
                same += <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> (similarity := same / max_len) &gt; max_similarity:
            max_similarity = similarity
            word_res = word
    <span class="hljs-keyword">return</span> word_res
</div></code></pre>
<p>通过接收识别出的单词和词典作为参数，返回单词的词根。</p>
<p>经过测试，这种算法能够比较准确地找到答案，并且能够保证在出现多个释义时，能够找到最接近的选项，准确率很高。</p>
<h4 id="35-%E7%AD%94%E9%A2%98%E6%B5%81%E7%A8%8B%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><strong>3.5 答题流程和异常处理</strong></h4>
<p>对于答题的流程，在 answer 类中设计了一个 routine 函数用于处理流程，抛出异常。对于答案错误的判断如下</p>
<p>第一次若答错，会出现以下界面</p>
<p><img src="file:///g:/script/pic_used_in_word/wrong.png" alt="img">
所以，可以通过在一定时间差后获取点击的选项所在坐标的 RGB 值，通过判断其是否为红色。若为红色，则选择 option_result 的第二个选项
若依然错误，则会跳出一个解释词义的选项，并且有多行文字，此时再次调用 get_line 函数，若行数过大，则说明两次答案都错了，此时自动点击下方的继续按钮，进入下一题。</p>
<p>判断颜色的函数代码如下，可通过获取 rgb 值判断</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_green</span><span class="hljs-params">(rgb: tuple)</span> -&gt; bool:</span>
    <span class="hljs-string">"""
    两次都做错,会进入释义界面,在固定位置会有一个绿点,以此判断
    判断给定的 RGB 值是否属于绿色。
    """</span>
    r, g, b = rgb
    <span class="hljs-keyword">return</span> g &gt; r <span class="hljs-keyword">and</span> g &gt; b
</div></code></pre>
<p>至此，已经可以基本完成答题流程，实现较高的正确率。</p>
<h2 id="%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><strong><em>第四章</em></strong> <strong>运行结果</strong></h2>
<p>任意选取一次作业，进入界面选择10个单次后开始答题，此时需要输入单词个数10</p>
<p>读取单词生成词典时候控制台输出如下图：</p>
<p><img src="file:///g:/script/pic_used_in_word/runtime1.png" alt="img">
可见，程序正确读取了单词，第一行是读取的单词释义，同时在第二行输出当前的词典全部内容便于调试。程序成功生成了词典，释义以列表形式储存便于读取释义。</p>
<p>然后进入答题界面效果如下
<img src="file:///g:/script/pic_used_in_word/runtime2.png" alt="img"></p>
<p>此时，控制台会输出识别出来的的单词和最终的单词，中间便用到了我们写的还原词根的算法。比如：
<img src="file:///g:/script/pic_used_in_word/runtime3.png" alt="img">
<img src="file:///g:/script/pic_used_in_word/runtime4.png" alt="img">
可以发现，在遇到变形如rigged时，程序可以正确还原为原型，同时当识别错误时如disciose错识别为aisciose时候，可以纠正为正确的单词。</p>
<p>最后，程序会自动选择答案，并输出选择的答案，同时输出正确率。
<img src="file:///g:/script/pic_used_in_word/runtime5.png" alt="img"></p>
<p>经过多次测试，发现单词数量在15-20的时候效果最好，保证了正确率稳定在90%以上。并且效率较高。运行的视频在附件中。</p>
<p>至此，程序已经成功运行，并且能够实现识别-分析-答题一体，正确率较高，实现了自动答题的功能。</p>
<h2 id="%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%94%B6%E8%8E%B7%E4%B8%8E%E6%80%BB%E7%BB%93"><strong><em>第五章</em></strong> <strong>收获与总结</strong></h2>
<p>通过这次实验，我对python的强大功能有了进一步的了解，并且初始了一些计算机图形领域的一些应用和处理，提高了对python的理解和对编程的实际运用能力。</p>

</body>
</html>
